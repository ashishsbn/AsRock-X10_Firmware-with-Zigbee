--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -5,6 +5,7 @@ igmpproxy_SOURCES = \
 	confread.c \
 	ifvc.c \
 	igmp.c \
+	igmpv3.h \
 	igmpproxy.c \
 	igmpproxy.h \
 	kern.c \
--- a/src/igmp.c
+++ b/src/igmp.c
@@ -36,10 +36,12 @@
 */
 
 #include "igmpproxy.h"
+#include "igmpv3.h"
  
 // Globals                  
 uint32_t     allhosts_group;          /* All hosts addr in net order */
 uint32_t     allrouters_group;          /* All hosts addr in net order */
+uint32_t     alligmp3_group;
               
 extern int MRouterFD;
 
@@ -74,6 +76,7 @@ void initIgmp() {
 
     allhosts_group   = htonl(INADDR_ALLHOSTS_GROUP);
     allrouters_group = htonl(INADDR_ALLRTRS_GROUP);
+    alligmp3_group   = htonl(INADDR_ALLIGMPV3_GROUP);
 }
 
 /**
@@ -87,6 +90,7 @@ char *igmpPacketKind(u_int type, u_int c
     case IGMP_V1_MEMBERSHIP_REPORT:  return "V1 member report  ";
     case IGMP_V2_MEMBERSHIP_REPORT:  return "V2 member report  ";
     case IGMP_V2_LEAVE_GROUP:        return "Leave message     ";
+    case IGMP_V3_MEMBERSHIP_REPORT:  return "V3 member report  ";
     
     default:
         sprintf(unknown, "unk: 0x%02x/0x%02x    ", type, code);
@@ -103,7 +107,9 @@ void acceptIgmp(int recvlen) {
     register uint32_t src, dst, group;
     struct ip *ip;
     struct igmp *igmp;
-    int ipdatalen, iphdrlen, igmpdatalen;
+    struct igmpv3_report *igmpv3;
+    struct igmpv3_grec *grec;
+    int ipdatalen, iphdrlen, ngrec, nsrcs, i;
 
     if (recvlen < sizeof(struct ip)) {
         my_log(LOG_WARNING, 0,
@@ -164,10 +170,9 @@ void acceptIgmp(int recvlen) {
         return;
     }
 
-    igmp        = (struct igmp *)(recv_buf + iphdrlen);
-    group       = igmp->igmp_group.s_addr;
-    igmpdatalen = ipdatalen - IGMP_MINLEN;
-    if (igmpdatalen < 0) {
+    igmp = (struct igmp *)(recv_buf + iphdrlen);
+    if ((ipdatalen < IGMP_MINLEN) ||
+        (igmp->igmp_type == IGMP_V3_MEMBERSHIP_REPORT && ipdatalen <= IGMPV3_MINLEN)) {
         my_log(LOG_WARNING, 0,
             "received IP data field too short (%u bytes) for IGMP, from %s",
             ipdatalen, inetFmt(src, s1));
@@ -181,10 +186,47 @@ void acceptIgmp(int recvlen) {
     switch (igmp->igmp_type) {
     case IGMP_V1_MEMBERSHIP_REPORT:
     case IGMP_V2_MEMBERSHIP_REPORT:
+        group = igmp->igmp_group.s_addr;
         acceptGroupReport(src, group, igmp->igmp_type);
         return;
     
+    case IGMP_V3_MEMBERSHIP_REPORT:
+        igmpv3 = (struct igmpv3_report *)(recv_buf + iphdrlen);
+        grec = &igmpv3->igmp_grec[0];
+        ngrec = ntohs(igmpv3->igmp_ngrec);
+        while (ngrec--) {
+            if ((uint8_t *)igmpv3 + ipdatalen < (uint8_t *)grec + sizeof(*grec))
+                break;
+            group = grec->grec_mca.s_addr;
+            nsrcs = ntohs(grec->grec_nsrcs);
+            switch (grec->grec_type) {
+            case IGMPV3_MODE_IS_INCLUDE:
+            case IGMPV3_CHANGE_TO_INCLUDE:
+                if (nsrcs == 0) {
+                    acceptLeaveMessage(src, group);
+                    break;
+                } /* else fall through */
+            case IGMPV3_MODE_IS_EXCLUDE:
+            case IGMPV3_CHANGE_TO_EXCLUDE:
+            case IGMPV3_ALLOW_NEW_SOURCES:
+                acceptGroupReport(src, group, igmp->igmp_type);
+                break;
+            case IGMPV3_BLOCK_OLD_SOURCES:
+                break;
+            default:
+                my_log(LOG_INFO, 0,
+                    "ignoring unknown IGMPv3 group record type %x from %s to %s for %s",
+                    grec->grec_type, inetFmt(src, s1), inetFmt(dst, s2),
+                    inetFmt(group, s3));
+                break;
+            }
+            grec = (struct igmpv3_grec *)
+                (&grec->grec_src[nsrcs] + grec->grec_auxwords * 4);
+        }
+        return;   
+
     case IGMP_V2_LEAVE_GROUP:
+        group = igmp->igmp_group.s_addr;
         acceptLeaveMessage(src, group);
         return;
     
--- a/src/igmpproxy.h
+++ b/src/igmpproxy.h
@@ -209,6 +209,7 @@ struct Config *getCommonConfig();
 */
 extern uint32_t allhosts_group;
 extern uint32_t allrouters_group;
+extern uint32_t alligmp3_group;
 void initIgmp(void);
 void acceptIgmp(int);
 void sendIgmp (uint32_t, uint32_t, int, int, uint32_t,int);
--- /dev/null
+++ b/src/igmpv3.h
@@ -0,0 +1,48 @@
+/*
+**  igmpproxy - IGMP proxy based multicast router 
+**  Copyright (C) 2005 Johnny Egeland <johnny@rlo.org>
+**
+**  This program is free software; you can redistribute it and/or modify
+**  it under the terms of the GNU General Public License as published by
+**  the Free Software Foundation; either version 2 of the License, or
+**  (at your option) any later version.
+**
+**  This program is distributed in the hope that it will be useful,
+**  but WITHOUT ANY WARRANTY; without even the implied warranty of
+**  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+**  GNU General Public License for more details.
+**
+**  You should have received a copy of the GNU General Public License
+**  along with this program; if not, write to the Free Software
+**  Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+**
+*/
+/**
+*   igmpv3.h - Header file for common IGMPv3 includes.
+*/
+
+struct igmpv3_grec {
+    u_int8_t grec_type;
+    u_int8_t grec_auxwords;
+    u_int16_t grec_nsrcs;
+    struct in_addr grec_mca;
+    struct in_addr grec_src[0];
+};
+
+struct igmpv3_report {
+    u_int8_t igmp_type;
+    u_int8_t igmp_resv1;
+    u_int16_t igmp_cksum;
+    u_int16_t igmp_resv2;
+    u_int16_t igmp_ngrec;
+    struct igmpv3_grec igmp_grec[0];
+};
+
+#define IGMPV3_MODE_IS_INCLUDE   1
+#define IGMPV3_MODE_IS_EXCLUDE   2
+#define IGMPV3_CHANGE_TO_INCLUDE 3
+#define IGMPV3_CHANGE_TO_EXCLUDE 4
+#define IGMPV3_ALLOW_NEW_SOURCES 5
+#define IGMPV3_BLOCK_OLD_SOURCES 6
+
+#define IGMPV3_MINLEN 12
--- a/src/os-dragonfly.h
+++ b/src/os-dragonfly.h
@@ -3,6 +3,10 @@
 #include <netinet/ip.h>
 #include <netinet/igmp.h>
 
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
+
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
+
 static inline u_short ip_data_len(const struct ip *ip)
 {
 	return ip->ip_len;
--- a/src/os-freebsd.h
+++ b/src/os-freebsd.h
@@ -12,6 +12,10 @@
 #define IGMP_V2_LEAVE_GROUP IGMP_HOST_LEAVE_MESSAGE
 #endif
 
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
+
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
+
 static inline u_short ip_data_len(const struct ip *ip)
 {
 	return ip->ip_len;
--- a/src/os-linux.h
+++ b/src/os-linux.h
@@ -4,6 +4,10 @@
 #include <netinet/ip.h>
 #include <netinet/igmp.h>
 
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
+
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
+
 static inline u_short ip_data_len(const struct ip *ip)
 {
 	return ntohs(ip->ip_len) - (ip->ip_hl << 2);
--- a/src/os-netbsd.h
+++ b/src/os-netbsd.h
@@ -6,8 +6,11 @@
 #define IGMP_MEMBERSHIP_QUERY IGMP_HOST_MEMBERSHIP_QUERY
 #define IGMP_V1_MEMBERSHIP_REPORT IGMP_v1_HOST_MEMBERSHIP_REPORT
 #define IGMP_V2_MEMBERSHIP_REPORT IGMP_v2_HOST_MEMBERSHIP_REPORT
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
 #define IGMP_V2_LEAVE_GROUP IGMP_HOST_LEAVE_MESSAGE
 
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
+
 static inline u_short ip_data_len(const struct ip *ip)
 {
 	return ip->ip_len;
--- a/src/os-openbsd.h
+++ b/src/os-openbsd.h
@@ -6,9 +6,11 @@
 #define IGMP_MEMBERSHIP_QUERY IGMP_HOST_MEMBERSHIP_QUERY
 #define IGMP_V1_MEMBERSHIP_REPORT IGMP_v1_HOST_MEMBERSHIP_REPORT
 #define IGMP_V2_MEMBERSHIP_REPORT IGMP_v2_HOST_MEMBERSHIP_REPORT
+#define IGMP_V3_MEMBERSHIP_REPORT 0x22
 #define IGMP_V2_LEAVE_GROUP IGMP_HOST_LEAVE_MESSAGE
 
 #define INADDR_ALLRTRS_GROUP INADDR_ALLROUTERS_GROUP
+#define INADDR_ALLIGMPV3_GROUP ((in_addr_t) 0xe0000016)
 
 static inline u_short ip_data_len(const struct ip *ip)
 {
--- a/src/rttable.c
+++ b/src/rttable.c
@@ -100,6 +100,10 @@ void initRouteTable() {
             
             //k_join(allrouters_group, Dp->InAdr.s_addr);
             joinMcGroup( getMcGroupSock(), Dp, allrouters_group );
+
+            my_log(LOG_DEBUG, 0, "Joining all igmpv3 multicast routers group %s on vif %s",
+                         inetFmt(alligmp3_group,s1),inetFmt(Dp->InAdr.s_addr,s2));
+            joinMcGroup( getMcGroupSock(), Dp, alligmp3_group );
         }
     }
 }
