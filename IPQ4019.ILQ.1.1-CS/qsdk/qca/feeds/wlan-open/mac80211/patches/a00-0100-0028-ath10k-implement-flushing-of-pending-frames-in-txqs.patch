--- a/drivers/net/wireless/ath/ath10k/core.h
+++ b/drivers/net/wireless/ath/ath10k/core.h
@@ -626,6 +626,7 @@ static inline const char *ath10k_scan_st
 
 enum ath10k_tx_pause_reason {
 	ATH10K_TX_PAUSE_Q_FULL,
+	ATH10K_TX_PAUSE_Q_FLUSH_PENDING,
 	ATH10K_TX_PAUSE_MAX,
 };
 
--- a/drivers/net/wireless/ath/ath10k/htt_rx.c
+++ b/drivers/net/wireless/ath/ath10k/htt_rx.c
@@ -2241,6 +2241,7 @@ void ath10k_htt_t2h_msg_handler(struct a
 		}
 
 		ath10k_txrx_tx_unref(htt, &tx_done);
+		ath10k_mac_tx_push_pending(ar);
 		break;
 	}
 	case HTT_T2H_MSG_TYPE_TX_COMPL_IND:
@@ -2373,6 +2374,8 @@ static void ath10k_htt_txrx_compl_task(u
 		dev_kfree_skb_any(skb);
 	}
 
+	ath10k_mac_tx_push_pending(ar);
+
 	spin_lock_bh(&htt->rx_ring.lock);
 	while ((skb = __skb_dequeue(&htt->rx_compl_q))) {
 		resp = (struct htt_resp *)skb->data;
--- a/drivers/net/wireless/ath/ath10k/mac.c
+++ b/drivers/net/wireless/ath/ath10k/mac.c
@@ -3720,6 +3720,85 @@ static void ath10k_mac_tx_wake(struct ie
 	ath10k_htt_tx_txq_update(hw, txq);
 }
 
+struct ath10k_mac_tx_push_arg {
+	struct ieee80211_hw *hw;
+	bool more;
+};
+
+static void ath10k_mac_tx_push_pending_txq(struct ieee80211_hw *hw,
+					   struct ieee80211_txq *txq,
+					   struct ath10k_mac_tx_push_arg *arg)
+{
+	bool can_push;
+	bool has_more;
+	int ret;
+
+	if (!txq)
+		return;
+
+	while (txq->qdepth > 0) {
+		ret = ath10k_mac_tx_push_txq(hw, txq);
+		if (ret)
+			break;
+	}
+
+	can_push = ath10k_mac_tx_can_push(hw, txq);
+	has_more = txq->qdepth > 0;
+
+	if (can_push && has_more)
+		arg->more = true;
+}
+
+static void ath10k_mac_tx_push_pending_vif_iter(void *data,
+						u8 *mac,
+						struct ieee80211_vif *vif)
+{
+	struct ath10k_mac_tx_push_arg *arg = data;
+	struct ieee80211_hw *hw = arg->hw;
+
+	ath10k_mac_tx_push_pending_txq(hw, vif->txq, arg);
+}
+
+static void ath10k_mac_tx_push_pending_sta_iter(void *data,
+						struct ieee80211_sta *sta)
+{
+	struct ath10k_mac_tx_push_arg *arg = data;
+	struct ieee80211_hw *hw = arg->hw;
+	int tid;
+
+	for (tid = 0; tid < ARRAY_SIZE(sta->txq); tid++)
+		ath10k_mac_tx_push_pending_txq(hw, sta->txq[tid], arg);
+}
+
+void ath10k_mac_tx_push_pending(struct ath10k *ar)
+{
+	struct ieee80211_hw *hw = ar->hw;
+	struct ath10k_mac_tx_push_arg arg = {};
+
+	if (likely(!(ar->tx_paused & BIT(ATH10K_TX_PAUSE_Q_FLUSH_PENDING))))
+		return;
+
+	arg.hw = hw;
+	arg.more = false;
+
+	ieee80211_iterate_active_interfaces_atomic(hw,
+						   IEEE80211_IFACE_ITER_NORMAL,
+						   ath10k_mac_tx_push_pending_vif_iter,
+						   &arg);
+	if (arg.more)
+		return;
+
+	ieee80211_iterate_stations_atomic(hw,
+					  ath10k_mac_tx_push_pending_sta_iter,
+					  &arg);
+	if (arg.more)
+		return;
+
+	spin_lock_bh(&ar->htt.tx_lock);
+	ath10k_mac_tx_unlock(ar, ATH10K_TX_PAUSE_Q_FLUSH_PENDING);
+	spin_unlock_bh(&ar->htt.tx_lock);
+}
+
 /************/
 /* Scanning */
 /************/
--- a/drivers/net/wireless/ath/ath10k/mac.h
+++ b/drivers/net/wireless/ath/ath10k/mac.h
@@ -75,6 +75,7 @@ void ath10k_mac_tx_unlock(struct ath10k
 void ath10k_mac_vif_tx_lock(struct ath10k_vif *arvif, int reason);
 void ath10k_mac_vif_tx_unlock(struct ath10k_vif *arvif, int reason);
 bool ath10k_mac_tx_frm_has_freq(struct ath10k *ar);
+void ath10k_mac_tx_push_pending(struct ath10k *ar);
 
 static inline struct ath10k_vif *ath10k_vif_to_arvif(struct ieee80211_vif *vif)
 {
